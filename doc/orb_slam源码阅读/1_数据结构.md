# 地图点
## 属性
1. pos 世界坐标
2. KeyFrame 
3. map
4. mNormalVector 观测方向，相机中心点和地图点的单位向量（多个观测点取平均）
5. mfMinDistance，mfMaxDistance
5. mObservations 可以看到该地图点的关键帧
6. mnFound 被发现的次数，追踪时增加


## 构造时机
1. 地图初始化
2. 局部建图
3. 跟踪定位，仅双目和深度

## 释放
setBadFlag之后释放。 // 标记为无效后没有被真正释放，可能怕出现野指针。
1. 所有关键点要移除对该点的观测
2. 从地图中删除

## 重要操作
1. 更换地图点 （代码中有bug)
2. 更新描述子, 计算描述子距离时，求每一个描述子到其它所有描述子的距离，然后求中值，中值越小，越相似
```c++
    for(size_t i=0;i<N;i++)
    {
        // 第i个描述子到其它所有描述子之间的距离
        // vector<int> vDists(Distances[i],Distances[i]+N);
		vector<int> vDists(Distances[i].begin(), Distances[i].end());
		sort(vDists.begin(), vDists.end());

        // 获得中值
        int median = vDists[0.5*(N-1)];
        
        // 寻找最小的中值
        if(median<BestMedian)
        {
            BestMedian = median;
            BestIdx = i;
        }
    }
```
3. 预测地图点在某帧中的金字塔的层数 $ ceil(log(dmax/d)/log(1.2)) $, 距离越大，层级越低，搜索半径越小 （怀疑这儿是bug）
```c++
int MapPoint::PredictScale(const float &currentDist, KeyFrame* pKF)
{
    float ratio;
    {
        unique_lock<mutex> lock(mMutexPos);
        // mfMaxDistance = ref_dist*levelScaleFactor 为参考帧考虑上尺度后的距离
        // ratio = mfMaxDistance/currentDist = ref_dist/cur_dist
        // FIX me  ratio = currentDist/mfMinDistance;
        ratio = mfMaxDistance/currentDist;
    }

    // 取对数
    int nScale = ceil(log(ratio)/pKF->mfLogScaleFactor);
    if(nScale<0)
        nScale = 0;
    else if(nScale>=pKF->mnScaleLevels)
        nScale = pKF->mnScaleLevels-1;

    return nScale;
}

```




