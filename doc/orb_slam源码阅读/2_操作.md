# 初始化
1. 初始化要比一般图像提取更多的特征点
## 单目初始化
从第二帧开始初始化。 具体原理参考slam14讲（深刻理解公式变化，然后对照代码学习）
1. 宽松的特征点匹配策略（0.9），搜索100个以上匹配点，少于100个放弃
2. 在匹配点中选取8个匹配为一组，选择n个组（参数)
3. 分别计算基础矩阵F和单应矩阵H，并计算得分
4.  SH/(SH+SF) > 0.4 选择单应矩阵
5. 三角化
```c++
    // Launch threads to compute in parallel a fundamental matrix and a homography
    vector<bool> vbMatchesInliersH, vbMatchesInliersF;
    float SH, SF;
    cv::Mat H, F;

    thread threadH(&Initializer::FindHomography,this,ref(vbMatchesInliersH), ref(SH), ref(H));
    thread threadF(&Initializer::FindFundamental,this,ref(vbMatchesInliersF), ref(SF), ref(F));

    // Wait until both threads have finished
    threadH.join();
    threadF.join();

    // Compute ratio of scores
    float RH = SH/(SH+SF);

    // Try to reconstruct from homography or fundamental depending on the ratio (0.40-0.45)
    if(RH>0.40)
        return ReconstructH(vbMatchesInliersH,H,mK,R21,t21,vP3D,vbTriangulated,1.0,50);
    else //if(pF_HF>0.6)
        return ReconstructF(vbMatchesInliersF,F,mK,R21,t21,vP3D,vbTriangulated,1.0,50);
```
### 单次迭代计算单应矩阵H
1. 正则化特征点的坐标（图像坐标正则化为标准高斯分布）
2. 使用随机选取的8个匹配点集，计算正则化后点单应矩阵H
3. 恢复原来点的H矩阵
3. 计算得分
```c++
       // Reprojection error in first image
        // x2in1 = H12*x2

        const float w2in1inv = 1.0/(h31inv*u2+h32inv*v2+h33inv);
        const float u2in1 = (h11inv*u2+h12inv*v2+h13inv)*w2in1inv;
        const float v2in1 = (h21inv*u2+h22inv*v2+h23inv)*w2in1inv;

        const float squareDist1 = (u1-u2in1)*(u1-u2in1)+(v1-v2in1)*(v1-v2in1);

        const float chiSquare1 = squareDist1*invSigmaSquare;

        if(chiSquare1>th)
            bIn = false;
        else
            score += th - chiSquare1;
```
```
在ORB-SLAM2中，求解单应矩阵（homography matrix）时进行特征点正则化的目的是为了提高计算的稳定性和准确性。特征点正则化（feature point normalization）通常指的是将特征点坐标从原始图像坐标系转换到一个标准化的坐标系中，使得这些点的分布更加均匀，从而改善数值稳定性。

为什么需要特征点正则化？
数值稳定性：
在计算单应矩阵时，特征点的坐标范围可能非常大（例如，图像尺寸可能是几千像素），这可能导致数值计算不稳定。通过正则化，可以将特征点坐标缩放到一个较小的范围内（如 [-1, 1] 或 [0, 1]），从而提高数值稳定性。
均值和方差控制：
正则化可以将特征点的均值调整到零附近，并且使方差保持在一个合理的范围内。这有助于提高数值计算的稳定性，避免因坐标值过大而导致的数值溢出或精度损失。
几何稳定性：
特征点正则化可以使特征点的分布更加均匀，从而改善几何稳定性。在计算单应矩阵时，均匀分布的特征点可以更好地覆盖图像的空间范围，提高计算结果的可靠性。
算法性能：
许多几何计算算法（如RANSAC）对输入数据的分布有要求。正则化后的特征点可以更好地满足这些算法的要求，提高算法的性能。
特征点正则化的过程
中心化：
将特征点坐标相对于图像中心进行平移，使其均值为零。
```
### 计算基础矩阵F
基础矩阵计算后，可分解为两个R，t。分别计算分数
## 双目初始化
# 前端
|操作|用途|步骤|数据量|其他|
|--|----|---|---|---|
|关键帧跟踪|1.地图刚初始化后；<br> 2.恒速跟踪失败 <br> 3.上一帧进行重定位跟踪过|1. bow计算 <br> 2. 通过bow搜索相似特征点对应的地图点( < 125 失败>)  <br> 3.位姿计算（内点数>10 成功） <br>|上一个关键帧<br>通过bow进行关键点全量搜索 <br> 匹配点距离少于50 |可能失败，失败后进行重定位跟踪|
|恒速跟踪|上一帧跟踪成功|1. 更新地图（位姿和双目相机创建临时地图点）<br> 2. 匹配 3. 位姿优化|1. 通过重投影搜索附近地图点，距离小于100|-|
|重定位跟踪|1. 上一帧跟踪失败，地图重置|1.从keyFrame 中挑选关键帧（基于bow中相同的单词，相当严格，doc/orb_slam源码阅读/1_数据结构.md） <br> 2. |-|-|
|局部地图跟踪|1. 用于上述地图粗定位后的精定位|1. 通过共视点与更多关键帧建立关系 <br> 2. 将关键帧的地图点尝试投影到当前帧，得到更多的地图点 <br> 3. 位姿优化 4. 通过内点判断是否成功|1. 有共同地图点所有关键帧（若< 80, 则其共视关系好的，父子关键帧>）<br> 2. 关键帧的地图点查找，基于Bow节点（非单词）（<15个,一个候选帧失败）<br> 3. 使用Pnp求解和关键帧相对位姿  <br> 4. 通过g2o优化位姿(内点 < 15 失败 > 50成功)，<br> 5. 搜索更多的匹配点， 重新优化 内点 > 50成功|1. 计算量很大 </br> |
# 后端
## 建图
### 创建关键帧
1. 初始化时
2. 追踪时
影响因子
- 当前系统可以插入关键帧，见localmap
- 追踪到的关键点较少,外点较多
- 系统空闲程度
``` c++
  // Condition 1a: More than "MaxFrames" have passed from last keyframe insertion
    const bool c1a = mCurrentFrame.mnId>=mnLastKeyFrameId+mMaxFrames;
    // Condition 1b: More than "MinFrames" have passed and Local Mapping is idle(空闲)
    const bool c1b = (mCurrentFrame.mnId>=mnLastKeyFrameId+mMinFrames && bLocalMappingIdle);
    //Condition 1c: tracking is weak
    const bool c1c =  mSensor!=System::MONOCULAR && (mnMatchesInliers<nRefMatches*0.25 || bNeedToInsertClose) ;
    // Condition 2: Few tracked points compared to reference keyframe. Lots of visual odometry compared to map matches.
    const bool c2 = ((mnMatchesInliers<nRefMatches*thRefRatio|| bNeedToInsertClose) && mnMatchesInliers>15);

    if((c1a||c1b||c1c)&&c2)
    {
        // If the mapping accepts keyframes, insert keyframe.
        // Otherwise send a signal to interrupt BA
        if(bLocalMappingIdle)
        {
            return true;
        }
        else
        {
            mpLocalMapper->InterruptBA();
            if(mSensor!=System::MONOCULAR)
            {
                if(mpLocalMapper->KeyframesInQueue()<3)
                    return true;
                else
                    return false;
            }
            else
                return false;
        }
    } 
```
建图之后，非单目相机建立地图点，至少建立100个。
### 局部建图中对关键帧的操作
主要函数 LocalMapping::ProcessNewKeyFrame() 见数据结构，localmap

## 局部优化
见优化
# 回环检测
## 检测
## 优化

- [x]周一跟踪相关
- []周二初始化
- [x]周三局部建图
- []周四回环检测



